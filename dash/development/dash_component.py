import copy
import json
import os
import collections
import itertools
import textwrap
import functools
# noinspection PyUnresolvedReferences
import typing  # noqa: F401

import six
import stringcase

from .base_component import ComponentRegistry as _Registry
from ._all_keywords import kwlist as _kwlist


def _default_prop_type(_):
    return 'typing.Any'


def _optional(value, type_info):
    if not type_info.get('required'):
        return 'typing.Optional[{}]'.format(value)
    return value


FILTERED_PROPS = (
    'setProps',
    'fireEvents',
)

FILTERED_PROP_TYPES = (
    'func',
    'custom',
    'symbol',
    'instanceOf'
)

PROP_TYPING_MAPPING = {
    'array': lambda t: 'typing.List',
    'arrayOf': lambda t: 'typing.List[{}]'.format(
        PROP_TYPING_MAPPING.get(
            t['value']['name'],
            _default_prop_type
        )(t['value'])
    ),
    'object': lambda t: 'typing.Dict',
    'shape': lambda t: 'typing.Dict',  # TODO How ?
    'string': lambda t: 'str',
    'bool': lambda t: 'bool',
    'number': lambda t: 'float',
    'node': lambda t: 'typing.Union[str, number, DashComponent]',
    'func': lambda t: 'None',
    'element': lambda t: 'DashComponent',
    'oneOf': _default_prop_type,  # TODO How ?
    'union': lambda t: 'typing.Union[{}]'.format(
        ','.join(set(x['name'] for x in t['value']))),
    # oneOfType get serialized to union...
    'any': _default_prop_type,
    'custom': _default_prop_type,
    # There is no proper typing support for enum.
    # Maybe put the values in the docstring ?
    'enum': lambda t: 'typing.Union[{}]'.format(
        ','.join(set(
            PROP_TYPING_MAPPING.get(
                x.get('name'),
                _default_prop_type
            )(x)
            for x in t['value']
        ))
    )
}

FLOW_TYPING_MAPPING = {
    'array': PROP_TYPING_MAPPING['array'],
    'boolean': PROP_TYPING_MAPPING['bool'],
    'number': PROP_TYPING_MAPPING['number'],
    'string': PROP_TYPING_MAPPING['string'],
    'Object': PROP_TYPING_MAPPING['object'],
    'any': _default_prop_type,
    'Element': PROP_TYPING_MAPPING['element'],
    'Node': PROP_TYPING_MAPPING['node'],
    'union': PROP_TYPING_MAPPING['union'],
    'Array': PROP_TYPING_MAPPING['array'],
    'signature': PROP_TYPING_MAPPING['object'],
}


# Making the props with typing.Optional removes the typing errors...
# PROP_TYPING_MAPPING = {
#     k: lambda t: _optional(_PROP_TYPING_MAPPING[t['type']['name']](t), t)
#     for k in _PROP_TYPING_MAPPING
# }

DEFAULT_PROP_MAPPING = {
    'array': json.dumps,
    'arrayOf': json.dumps,
    'object': lambda t: json.dumps,
    'shape': lambda t: json.dumps,
    'string': lambda t: t,
    'bool': lambda t: str(str(t).lower() == 'true'),
    'number': str,
    'node': json.dumps,
    'func': lambda t: 'None',
    'element': lambda t: 'None',
    'oneOf': str,
    'union': str,
    'any': str
}

_generated_class_template = '''
"""
Autogenerated file
DO NOT EDIT.
CONTENT WILL BE OVERWRITTEN!

WARNING:
Do not import this file directly!
It can lead to circular import issues.
"""
import collections
import typing

from dash.development.dash_component import DashComponent, UNDEFINED


class {component_name}(DashComponent):
    """
{description}
    """
    _prop_names = [
{props_names}
    ]
    _namespace = '{namespace}'
    _required_props = [{required_props}
    ]
    _prop_types = collections.OrderedDict({prop_types}
    _args = [{args}
    ]
    _kwargs = [{kwargs}
    ]
    _typename = '{typename}'

    def __init__(
        self,
{init_props}
        **kwargs
    ):
        {init_types}
        """
{props_docstring}
        """
        kw = kwargs.copy()
        # Insert the args as kwargs so we get the prop name for setattr.
        # kwargs can also contains wildcard attributes.
        kw.update({kws}
        DashComponent.__init__(self, **kw)
'''.lstrip()  # Remove the first newline

_user_klass_template = '''
"""
{namespace}
{component_name}.py

User defined class for {component_name}.
Edit this file to your liking, it will not get regenerated.
"""
from ._{base_filename} import _{component_name}


class {component_name}(_{component_name}):
    pass
'''.lstrip()

_init_padding = '        '

# mypy typing syntax + disable line too long
_init_types_template = '# type: ({}) -> None # noqa: E501'


# noinspection PyClassHasNoInit
class _Undefined(object):
    """
    Mark a difference between None and not supplied.
    The user can set a value to None and we should take it into account when
    serializing the component to include that prop.
    A falsy check is not enough.
    """
    _singleton = None  # There can only be one, like None
    __slots__ = ()  # no attribute can be added.

    @classmethod  # important, otherwise not the good __new__
    def __new__(cls, *args, **kwargs):
        if not cls._singleton:
            cls._singleton = super(_Undefined, cls).__new__(*args, **kwargs)
            return cls._singleton
        raise Exception('There can only be one UNDEFINED')

    def __repr__(self):
        return 'undefined'

    def __str__(self):
        return 'undefined'


UNDEFINED = _Undefined()


# noinspection PyProtectedMember
class _ComponentPropDescriptor(object):
    """
    Property descriptor for component props.

    Setter send a prop_change "event".
    Getter try to get the default prop if UNDEFINED.
    """
    def __init__(self, prop_name, prop_type):
        # Not using self.name
        # python>=3.6 get it automatically with __set_name__
        # while python 2 is stuck in limbo.
        self.prop_name = prop_name
        self.prop_type = prop_type

    def __set__(self, instance, value):
        # NEVER EVER USE getattr/setattr inside a descriptor! (infinite loop)
        old_value = instance._prop_values.get(self.prop_name)
        instance._prop_values[self.prop_name] = _Registry.on_prop_change(
            instance, self.prop_name, value, old_value, self.prop_type
        )

    def __get__(self, instance, owner):
        value = instance._prop_values.get(self.prop_name)
        if value is not UNDEFINED:
            return value
        return _Registry.get_default_prop(instance, self.prop_name)

    def __delete__(self, instance):
        del instance._prop_values[self.prop_name]


class _DashComponentMeta(type):
    _class_cache = {}
    __class_cache = []

    def __new__(mcs, name, bases, attributes):
        module_name = attributes.get('__module__')
        namespace = module_name.split('.')[0]
        cache_key = '{}.{}'.format(module_name, name)
        # Wrapping classes is expansive, cache the result.
        component = mcs._class_cache.get(cache_key)
        if component:
            return component

        if module_name != 'builtins' and name != 'Component':
            # Register the component namespace.
            _Registry.registry.add(namespace)
        new_attributes = copy.copy(attributes)

        # Add a prop descriptor for each react props.
        for prop, prop_type in attributes.get('_prop_types').items():
            new_attributes[prop] = _ComponentPropDescriptor(prop, prop_type)

        def wrap_init():
            original_init = attributes.get('__init__')

            @functools.wraps(original_init)
            def _init_wrap(self, *args, **kwargs):
                # Bonus issue https://github.com/plotly/dash/issues/268
                new_args = list(args)
                new_kwargs = dict(kwargs)
                if len(args) < len(self._args):
                    start_index = len(args)
                    missing = self._args[start_index:]

                    # Get the default value if registered.
                    for m in missing:
                        default = _Registry.get_default_prop(self, m)
                        if default:
                            new_args.append(default)
                        else:
                            raise Exception('Missing prop: {}'.format(m))

                    if len(new_args) < len(self._args):
                        raise Exception(
                            'Missing props : {}'.format(
                                self._args[len(new_args):]))

                # Insert python default props handling.
                for k in self._prop_names:
                    if k not in kwargs and k is UNDEFINED:
                        default = _Registry.get_default_prop(self, k)
                        if default is not UNDEFINED:
                            new_kwargs[k] = default

                original_init(self, *new_args, **new_kwargs)
            return _init_wrap

        if name != 'DashComponent':
            new_attributes['__init__'] = wrap_init()
        # Qualified name is import name ie: dash_table.DataTable
        # and not the full module name to the component:
        # dash_table.data_table.Datable
        new_attributes['_qualified_name'] = '{}.{}'.format(namespace, name)

        # Create the new class.
        component = type.__new__(mcs, name, bases, new_attributes)

        mcs._class_cache[cache_key] = component
        return component


@six.add_metaclass(_DashComponentMeta)
class DashComponent:
    """
    Dash base component.
    """
    _prop_names = []
    _namespace = ''
    _required_props = ''
    _prop_types = collections.OrderedDict()
    _args_len = 0
    _args = []
    _kwargs = []
    _typename = ''
    _qualified_name = ''

    def __init__(self, **kwargs):
        self._prop_values = {}
        for k, v in kwargs.items():
            if k in self._prop_names and v is not UNDEFINED:
                setattr(self, k, v)

    def to_plotly_json(self):
        # Use getattr so it goes into the descriptor __get__ for default value
        props = {
            k: v for k, v in
            ((x, getattr(self, x, None)) for x in self._prop_names)
            if v is not UNDEFINED
        }
        as_json = {
            'props': props,
            'type': self._typename,
            'namespace': self._namespace
        }
        return as_json

    def traverse(self):
        for _, children in self.traverse_with_path():
            yield children

    def traverse_with_path(self):
        component_path = '//' + self.component_path

        children = getattr(self, 'children', None)
        if isinstance(children, DashComponent):
            current_path = component_path + '/' + children.component_path
            yield current_path, children
            for path, child in children.traverse_with_path():
                yield current_path + '/' + path, child

        if isinstance(children, (tuple, collections.MutableMapping)):
            for i, child in enumerate(children):
                current_path = '{}/{}'.format(component_path, i)
                if isinstance(child, DashComponent):
                    current_path = current_path + '/' + child.component_path
                    yield current_path, child
                    for path, c in child.traverse_with_path():
                        yield current_path + '/' + path, c
                else:
                    yield current_path + '/' + type(child).__name__, child

    def __repr__(self):
        return json.dumps(self.to_plotly_json())

    @property
    def component_path(self):
        component_id = getattr(self, 'id', None)
        return '{}#{}'.format(self._qualified_name, component_id)\
            if component_id else self._qualified_name


def generate_component(name, props, description, project_shortname):
    """
    Generate a python dash component class file.

    :param name: Name of the component. `displayName` in the metadata.
    :param props: Props of the component. `props` in the metadata.
    :param description: Raw description from `description` in the metadata.
    :param project_shortname: The project namespace where the components files
        will be generated.
    :return:
    """
    base_filename = stringcase.snakecase(name)
    filtered_props = collections.OrderedDict({
        k: v for k, v in props.items()
        if
        k not in FILTERED_PROPS
        and not k.endswith('*')
        and k not in _kwlist
        and v.get('type', {}).get('name') not in FILTERED_PROP_TYPES
    })
    props_docs = {
        k: v.get('description', '') for k, v in filtered_props.items()
    }

    required_props = [
        k for k, v in filtered_props.items() if v.get('required')
    ]

    args = []
    kwargs = []
    kwargs_keys = []
    default_children = 'None'
    init_types = {}

    # Generate init required args and kwargs with default values
    for prop, prop_info in filtered_props.items():
        prop_default = prop_info.get('defaultValue')
        required = prop in required_props

        type_info = prop_info.get('type', {})
        init_types[prop] = PROP_TYPING_MAPPING.get(
            type_info.get('name'),
            _default_prop_type
        )(type_info)

        if not required:
            if not prop_default or prop_default.get('computed'):
                # computed default are set in the front end.
                mapped_default = 'UNDEFINED'
            else:
                mapped_default = DEFAULT_PROP_MAPPING.get(
                    type_info.get('name'),
                    json.dumps
                )(prop_default.get('value'))
                if prop == 'children':
                    default_children = mapped_default
            kwargs_keys.append(prop)
            kwargs.append('{}={}'.format(prop, mapped_default))
        else:
            args.append(prop)

        if type_info.get('name') == 'enum':
            props_docs[prop] += ' (Possible values: {})'.format(
                ', '.join(
                    x.get('value') for x in type_info.get('value')
                )
            )

    if 'id' not in filtered_props:
        # id is needed on every component for callback registration.
        # Some component may set it as required.
        kwargs = ['id=UNDEFINED'] + kwargs

    # Reorder children to appear first if required
    if 'children' in args:
        args.remove('children')
        args = ['children'] + args

    # Children also first in kwargs, if it got a default takes it.
    if 'children' in kwargs_keys:
        kwargs = ['children={}'.format(default_children)]\
                 + [x for x in kwargs if 'children' not in x]

    init_props = '\n'.join(
        '{}{},'.format(_init_padding, x) for x in itertools.chain(args, kwargs)
    )
    kws = '{\n' + ',\n'.join(
        "            '{0}': {0}".format(x) for x in filtered_props
    ) + '\n        })'

    prop_types = '{\n' + ',\n'.join(
        "       '{}': '{}'".format(k, v.get('type', {}).get('name', 'any'))
        for k, v in props.items()
    ) + '\n    })'

    init_typing = _init_types_template.format(
        ', '.join(init_types[x] for x in itertools.chain(args, kwargs_keys))
    )

    props_docstring = ''.join(
        '{}\n'.format(
            ' ' * 8 + ':param {}: {}'.format(
                prop, doc
            ).rstrip(),
        )
        for prop, doc in props_docs.items()
    )

    klass_string = _generated_class_template.format(
        component_name=name,
        description='\n'.join(
            '    {}'.format(x)
            for x in
            # Make sure the description has less than 79 char lines.
            textwrap.fill(description.replace('\r', ''), 74).split('\n')
        ),
        namespace=project_shortname,
        props_docstring=props_docstring,
        props_names=',\n'.join(
            "'{}'".format(x).rjust(10 + len(x)) for x in props.keys()),
        props=', '.join(filtered_props.keys()),
        required_props=','.join(
            "\n       '{}'".format(x) for x in required_props),
        init_props=init_props,
        kws=kws,
        prop_types=prop_types,
        args=','.join("\n        '{}'".format(x) for x in args),
        kwargs=','.join("\n        '{}'".format(x) for x in kwargs_keys),
        typename=name,
        init_types=init_typing
    ).replace('\r', '')

    # user_klass = _user_klass_template.format(
    #     component_name=name,
    #     namespace=project_shortname,
    #     base_filename=base_filename
    # ).replace('\r', '')

    # Write the generated component class file.
    with open(
            os.path.join(project_shortname,
                         '{}.py'.format(base_filename)), 'w') as f:
        f.write(klass_string)

    # user_klass_file = os.path.join(project_shortname,
    #                                '{}.py'.format(base_filename))
    # if not os.path.exists(user_klass_file):
    #     # Only generate if there's no user file.
    #     # So user modification are not overwritten.
    #     with open(user_klass_file, 'w') as f:
    #         f.write(user_klass)
